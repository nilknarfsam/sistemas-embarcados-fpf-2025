"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _ServerSecureChannelLayer_instances, _a, _ServerSecureChannelLayer_counter, _ServerSecureChannelLayer_status, _ServerSecureChannelLayer_messageBuilder, _ServerSecureChannelLayer_parent, _ServerSecureChannelLayer_protocolVersion, _ServerSecureChannelLayer_lastTokenId, _ServerSecureChannelLayer_defaultSecureTokenLifetime, _ServerSecureChannelLayer_clientCertificate, _ServerSecureChannelLayer_clientPublicKey, _ServerSecureChannelLayer_clientPublicKeyLength, _ServerSecureChannelLayer_messageChunker, _ServerSecureChannelLayer_timeoutId, _ServerSecureChannelLayer_open_secure_channel_onceClose, _ServerSecureChannelLayer_securityTokenTimeout, _ServerSecureChannelLayer_transactionsCount, _ServerSecureChannelLayer_transport, _ServerSecureChannelLayer_objectFactory, _ServerSecureChannelLayer_last_transaction_stats, _ServerSecureChannelLayer_startReceiveTick, _ServerSecureChannelLayer_endReceiveTick, _ServerSecureChannelLayer_startSendResponseTick, _ServerSecureChannelLayer_endSendResponseTick, _ServerSecureChannelLayer__bytesRead_before, _ServerSecureChannelLayer__bytesWritten_before, _ServerSecureChannelLayer__remoteAddress, _ServerSecureChannelLayer__remotePort, _ServerSecureChannelLayer_abort_has_been_called, _ServerSecureChannelLayer_idVerification, _ServerSecureChannelLayer_transport_socket_close_listener, _ServerSecureChannelLayer_tokenStack, _ServerSecureChannelLayer__build_message_builder, _ServerSecureChannelLayer__sendFatalErrorAndAbort, _ServerSecureChannelLayer__has_endpoint_for_security_mode_and_policy, _ServerSecureChannelLayer__rememberClientAddressAndPort, _ServerSecureChannelLayer__stop_security_token_watch_dog, _ServerSecureChannelLayer__start_security_token_watch_dog, _ServerSecureChannelLayer__prepare_security_token, _ServerSecureChannelLayer__stop_open_channel_watch_dog, _ServerSecureChannelLayer__cleanup_pending_timers, _ServerSecureChannelLayer__cancel_wait_for_open_secure_channel_request_timeout, _ServerSecureChannelLayer__install_wait_for_open_secure_channel_request_timeout, _ServerSecureChannelLayer__on_initial_open_secure_channel_request, _ServerSecureChannelLayer__wait_for_open_secure_channel_request, _ServerSecureChannelLayer__send_chunk, _ServerSecureChannelLayer__get_security_options_for_OPN, _ServerSecureChannelLayer__get_security_options_for_MSG, _ServerSecureChannelLayer__process_certificates, _ServerSecureChannelLayer__prepare_response_security_header, _ServerSecureChannelLayer__check_client_nonce, _ServerSecureChannelLayer__make_serverNonce, _ServerSecureChannelLayer__make_derivedKeys, _ServerSecureChannelLayer__handle_OpenSecureChannelRequest, _ServerSecureChannelLayer__abort, _ServerSecureChannelLayer__record_transaction_statistics, _ServerSecureChannelLayer__on_common_message, _ServerSecureChannelLayer__check_receiverCertificateThumbprint, _ServerSecureChannelLayer__on_OpenSecureChannelRequestError;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerSecureChannelLayer = void 0;
exports.isEmptyNonce = isEmptyNonce;
exports.nonceAlreadyBeenUsed = nonceAlreadyBeenUsed;
/* eslint-disable max-statements */
/**
 * @module node-opcua-secure-channel
 */
const crypto_1 = require("crypto");
const events_1 = require("events");
const chalk_1 = __importDefault(require("chalk"));
const node_opcua_assert_1 = require("node-opcua-assert");
const web_1 = require("node-opcua-crypto/web");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_packet_analyzer_1 = require("node-opcua-packet-analyzer");
const node_opcua_service_secure_channel_1 = require("node-opcua-service-secure-channel");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_transport_1 = require("node-opcua-transport");
const node_opcua_utils_1 = require("node-opcua-utils");
const node_opcua_object_registry_1 = require("node-opcua-object-registry");
const node_opcua_transport_2 = require("node-opcua-transport");
const node_opcua_common_1 = require("node-opcua-common");
const common_1 = require("../common");
const message_builder_1 = require("../message_builder");
const message_chunker_1 = require("../message_chunker");
const security_policy_1 = require("../security_policy");
const services_1 = require("../services");
const utils_1 = require("../utils");
const token_stack_1 = require("../token_stack");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("SecureChannel");
const errorLog = (0, node_opcua_debug_1.make_errorLog)("SecureChannel");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("SecureChannel");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("SecureChannel");
const allowNullRequestId = true;
let gLastChannelId = 0;
function getNextChannelId() {
    gLastChannelId += 1;
    return gLastChannelId;
}
function isValidSecurityPolicy(securityPolicy) {
    switch (securityPolicy) {
        case security_policy_1.SecurityPolicy.None:
        case security_policy_1.SecurityPolicy.Basic128Rsa15:
        case security_policy_1.SecurityPolicy.Basic256:
        case security_policy_1.SecurityPolicy.Basic256Sha256:
        case security_policy_1.SecurityPolicy.Aes128_Sha256_RsaOaep:
        case security_policy_1.SecurityPolicy.Aes256_Sha256_RsaPss:
            return node_opcua_status_code_1.StatusCodes.Good;
        default:
            return node_opcua_status_code_1.StatusCodes.BadSecurityPolicyRejected;
    }
}
/**
 * returns true if the nonce is null or zero (all bytes set to 0)
 */
function isEmptyNonce(nonce) {
    const countZero = nonce.reduce((accumulator, currentValue) => accumulator + (currentValue === 0 ? 1 : 0), 0);
    return countZero === nonce.length;
}
const g_alreadyUsedNonce = {};
function nonceAlreadyBeenUsed(nonce) {
    if (!nonce || isEmptyNonce(nonce)) {
        return false;
    }
    const hash = nonce.toString("base64");
    if (Object.prototype.hasOwnProperty.call(g_alreadyUsedNonce, hash)) {
        return true;
    }
    g_alreadyUsedNonce[hash] = {
        time: new Date()
    };
    return false;
}
/**
 */
class ServerSecureChannelLayer extends events_1.EventEmitter {
    get securityTokenCount() {
        (0, node_opcua_assert_1.assert)(typeof __classPrivateFieldGet(this, _ServerSecureChannelLayer_lastTokenId, "f") === "number");
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_lastTokenId, "f");
    }
    get remoteAddress() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer__remoteAddress, "f");
    }
    get remotePort() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer__remotePort, "f");
    }
    /**
     *
     */
    get aborted() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_abort_has_been_called, "f");
    }
    /**
     * the number of bytes read so far by this channel
     */
    get bytesRead() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f") ? __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").bytesRead : 0;
    }
    /**
     * the number of bytes written so far by this channel
     */
    get bytesWritten() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f") ? __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").bytesWritten : 0;
    }
    get transactionsCount() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_transactionsCount, "f");
    }
    /**
     * true when the secure channel has been opened successfully
     *
     */
    get isOpened() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_status, "f") === "open";
    }
    /**
     * true when the secure channel is assigned to a active session
     */
    get hasSession() {
        return Object.keys(this.sessionTokens).length > 0;
    }
    get certificateManager() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f").certificateManager;
    }
    /**
     * The unique hash key to identify this secure channel
     * @property hashKey
     */
    get hashKey() {
        return this.channelId;
    }
    get clientCertificate() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_clientCertificate, "f");
    }
    get status() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_status, "f");
    }
    constructor(options) {
        super();
        _ServerSecureChannelLayer_instances.add(this);
        _ServerSecureChannelLayer_counter.set(this, _a.g_counter++);
        _ServerSecureChannelLayer_status.set(this, "new");
        this.beforeHandleOpenSecureChannelRequest = async () => { };
        _ServerSecureChannelLayer_messageBuilder.set(this, void 0);
        /**
         * the channel message security policy
         */
        this.securityPolicy = security_policy_1.SecurityPolicy.Invalid;
        _ServerSecureChannelLayer_parent.set(this, void 0);
        _ServerSecureChannelLayer_protocolVersion.set(this, void 0);
        _ServerSecureChannelLayer_lastTokenId.set(this, void 0);
        _ServerSecureChannelLayer_defaultSecureTokenLifetime.set(this, void 0);
        _ServerSecureChannelLayer_clientCertificate.set(this, void 0);
        _ServerSecureChannelLayer_clientPublicKey.set(this, void 0);
        _ServerSecureChannelLayer_clientPublicKeyLength.set(this, void 0);
        _ServerSecureChannelLayer_messageChunker.set(this, void 0);
        _ServerSecureChannelLayer_timeoutId.set(this, void 0);
        _ServerSecureChannelLayer_open_secure_channel_onceClose.set(this, null);
        _ServerSecureChannelLayer_securityTokenTimeout.set(this, void 0);
        _ServerSecureChannelLayer_transactionsCount.set(this, void 0);
        _ServerSecureChannelLayer_transport.set(this, void 0);
        _ServerSecureChannelLayer_objectFactory.set(this, void 0);
        _ServerSecureChannelLayer_last_transaction_stats.set(this, void 0);
        _ServerSecureChannelLayer_startReceiveTick.set(this, void 0);
        _ServerSecureChannelLayer_endReceiveTick.set(this, void 0);
        _ServerSecureChannelLayer_startSendResponseTick.set(this, void 0);
        _ServerSecureChannelLayer_endSendResponseTick.set(this, void 0);
        _ServerSecureChannelLayer__bytesRead_before.set(this, void 0);
        _ServerSecureChannelLayer__bytesWritten_before.set(this, void 0);
        _ServerSecureChannelLayer__remoteAddress.set(this, void 0);
        _ServerSecureChannelLayer__remotePort.set(this, void 0);
        _ServerSecureChannelLayer_abort_has_been_called.set(this, void 0);
        _ServerSecureChannelLayer_idVerification.set(this, void 0);
        _ServerSecureChannelLayer_transport_socket_close_listener.set(this, void 0);
        _ServerSecureChannelLayer_tokenStack.set(this, void 0);
        this._on_response = null;
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_idVerification, {}, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_abort_has_been_called, false, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer__remoteAddress, "", "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer__remotePort, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKey, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKeyLength, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientCertificate, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_transport, new node_opcua_transport_1.ServerTCP_transport({ adjustLimits: options.adjustTransportLimits }), "f");
        this.channelId = getNextChannelId();
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_tokenStack, new token_stack_1.TokenStack(this.channelId), "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_parent, options.parent, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_protocolVersion, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_lastTokenId, 0, "f");
        this.timeout = options.timeout || 30000; // connection timeout
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_defaultSecureTokenLifetime, options.defaultSecureTokenLifetime || 600000, "f");
        // istanbul ignore next
        doDebug &&
            debugLog("server secure channel layer timeout = ", this.timeout, "defaultSecureTokenLifetime = ", __classPrivateFieldGet(this, _ServerSecureChannelLayer_defaultSecureTokenLifetime, "f"));
        // at first use a anonymous connection
        const securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
            receiverCertificateThumbprint: null,
            securityPolicyUri: security_policy_1.SecurityPolicy.None,
            senderCertificate: null
        });
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_startReceiveTick, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_endReceiveTick, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_startSendResponseTick, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_endSendResponseTick, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer__bytesRead_before, 0, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer__bytesWritten_before, 0, "f");
        this.securityMode = node_opcua_service_secure_channel_1.MessageSecurityMode.Invalid;
        // use to send response
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_messageChunker, new message_chunker_1.MessageChunker({
            securityHeader, // for OPN
            securityMode: node_opcua_service_secure_channel_1.MessageSecurityMode.Invalid,
            maxMessageSize: __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxMessageSize,
            maxChunkCount: __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxChunkCount
        }), "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_timeoutId, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_securityTokenTimeout, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_transactionsCount, 0, "f");
        this.sessionTokens = {};
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_objectFactory, options.objectFactory, "f");
        // xx #422 self.setMaxListeners(200); // increase the number of max listener
    }
    getTransportSettings() {
        return { maxMessageSize: __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxMessageSize };
    }
    dispose() {
        debugLog("ServerSecureChannelLayer#dispose");
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_open_channel_watch_dog).call(this);
        (0, node_opcua_assert_1.assert)(!__classPrivateFieldGet(this, _ServerSecureChannelLayer_timeoutId, "f"), "timeout must have been cleared");
        (0, node_opcua_assert_1.assert)(!__classPrivateFieldGet(this, _ServerSecureChannelLayer_securityTokenTimeout, "f"), "_securityTokenTimeout must have been cleared");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_parent, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_objectFactory, undefined, "f");
        if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f")) {
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").dispose();
            __classPrivateFieldSet(this, _ServerSecureChannelLayer_messageBuilder, undefined, "f");
        }
        if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageChunker, "f")) {
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageChunker, "f").dispose();
        }
        if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")) {
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").dispose();
            this.transport = undefined;
        }
        this.channelId = 0xdeadbeef;
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_timeoutId, null, "f");
        this.sessionTokens = {};
        this.removeAllListeners();
    }
    abruptlyInterrupt() {
        const clientSocket = __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")._socket;
        if (clientSocket) {
            clientSocket.end();
            clientSocket.destroy();
        }
    }
    /**
     * the endpoint associated with this secure channel
     *
     */
    getEndpointDescription(securityMode, securityPolicy, endpointUri) {
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f")) {
            return null; // throw new Error("getEndpointDescription - no parent");
        }
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f").getEndpointDescription(this.securityMode, securityPolicy, endpointUri);
    }
    setSecurity(securityMode, securityPolicy) {
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f")) {
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__build_message_builder).call(this);
        }
        (0, node_opcua_assert_1.assert)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f"));
        // TODO verify that the endpoint really supports this mode
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").setSecurity(securityMode, securityPolicy);
    }
    /**

     * @return the X509 DER form certificate
     */
    getCertificateChain() {
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f")) {
            throw new Error("expecting a valid parent");
        }
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f").getCertificateChain();
    }
    /**

     * @return  the X509 DER form certificate
     */
    getCertificate() {
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f")) {
            throw new Error("expecting a valid parent");
        }
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f").getCertificate();
    }
    getSignatureLength() {
        const firstCertificateInChain = this.getCertificate();
        const cert = (0, web_1.exploreCertificateInfo)(firstCertificateInChain);
        return cert.publicKeyLength; // 1024 bits = 128Bytes or 2048=256Bytes
    }
    /**

     * @return the privateKey
     */
    getPrivateKey() {
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f")) {
            return message_builder_1.invalidPrivateKey;
        }
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f").getPrivateKey();
    }
    /**
     *
     */
    init(socket, callback) {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").timeout = this.timeout;
        debugLog("Setting socket timeout to ", __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").timeout);
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").init(socket, (err) => {
            if (err) {
                callback(err);
            }
            else {
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__build_message_builder).call(this);
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__rememberClientAddressAndPort).call(this);
                // adjust sizes;
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageChunker, "f").maxMessageSize = __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxMessageSize;
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageChunker, "f").maxChunkCount = __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxChunkCount;
                // bind low level TCP transport to messageBuilder
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").on("chunk", (messageChunk) => {
                    // istanbul ignore next
                    if (node_opcua_transport_2.doTraceIncomingChunk) {
                        console.log((0, web_1.hexDump)(messageChunk));
                    }
                    __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").feed(messageChunk);
                });
                debugLog("ServerSecureChannelLayer : Transport layer has been initialized");
                debugLog("... now waiting for OpenSecureChannelRequest...");
                _a.registry.register(this);
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__wait_for_open_secure_channel_request).call(this, this.timeout);
                callback();
            }
        });
        // detect transport closure
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_transport_socket_close_listener, (err) => {
            debugLog("transport has send 'close' event " + (err ? err.message : "null"));
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__abort).call(this);
        }, "f");
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").on("close", __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport_socket_close_listener, "f"));
    }
    /**
     * @internal
     */
    send_response(msgType, response, message, callback) {
        const request = message.request;
        const requestId = message.requestId;
        (0, node_opcua_assert_1.assert)(allowNullRequestId || requestId !== 0);
        if (this.aborted) {
            debugLog("channel has been terminated , cannot send responses");
            return callback && callback(new Error("Aborted"));
        }
        // istanbul ignore next
        if (doDebug) {
            (0, node_opcua_assert_1.assert)(request.schema);
            (0, node_opcua_assert_1.assert)(allowNullRequestId || requestId > 0);
            // verify that response for a given requestId is only sent once.
            if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_idVerification, "f")) {
                __classPrivateFieldSet(this, _ServerSecureChannelLayer_idVerification, {}, "f");
            }
            (0, node_opcua_assert_1.assert)(!__classPrivateFieldGet(this, _ServerSecureChannelLayer_idVerification, "f")[requestId], " response for requestId has already been sent !! - Internal Error");
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_idVerification, "f")[requestId] = requestId;
        }
        if (utils_1.doPerfMonitoring) {
            // record tick : send response received.
            __classPrivateFieldSet(this, _ServerSecureChannelLayer_startSendResponseTick, (0, node_opcua_utils_1.get_clock_tick)(), "f");
        }
        const tokenId = message.securityHeader instanceof node_opcua_service_secure_channel_1.SymmetricAlgorithmSecurityHeader ? message.securityHeader.tokenId : 0;
        const channelId = this.channelId;
        const securityHeader = message.securityHeader;
        const securityOptions = msgType === "OPN" ? __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__get_security_options_for_OPN).call(this) : __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__get_security_options_for_MSG).call(this, tokenId);
        const chunkSize = __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").receiveBufferSize;
        let options = {
            channelId,
            securityOptions: {
                chunkSize,
                requestId,
                // to be adjusted
                signatureLength: 0,
                plainBlockSize: 0,
                cipherBlockSize: 0,
                sequenceHeaderSize: 0,
                ...securityOptions
            },
            securityHeader
        };
        response.responseHeader.requestHandle = request.requestHeader.requestHandle;
        if (message.request.requestHeader.returnDiagnostics === 0) {
            response.responseHeader.serviceDiagnostics = null;
        }
        else {
            // #  to do
        }
        /* istanbul ignore next */
        if (0 && doDebug) {
            debugLog(" options ", options);
            (0, node_opcua_packet_analyzer_1.analyze_object_binary_encoding)(response);
        }
        /* istanbul ignore next */
        if (utils_1.doTraceServerMessage) {
            (0, utils_1.traceResponseMessage)(response, tokenId, channelId, __classPrivateFieldGet(this, _ServerSecureChannelLayer_counter, "f"));
        }
        if (this._on_response) {
            this._on_response(msgType, response, message);
        }
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_transactionsCount, __classPrivateFieldGet(this, _ServerSecureChannelLayer_transactionsCount, "f") + 1, "f");
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageChunker, "f").securityMode = this.securityMode;
        const statusCode = __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageChunker, "f").chunkSecureMessage(msgType, options, response, (chunk) => {
            if (chunk) {
                __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__send_chunk).call(this, chunk);
            }
            else {
                /* istanbul ignore next */
                if (utils_1.doPerfMonitoring) {
                    // record tick 3 : transaction completed.
                    __classPrivateFieldSet(this, _ServerSecureChannelLayer_endSendResponseTick, (0, node_opcua_utils_1.get_clock_tick)(), "f");
                    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__record_transaction_statistics).call(this);
                    // dump some statistics about transaction ( time and sizes )
                    (0, utils_1._dump_transaction_statistics)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_last_transaction_stats, "f"));
                }
                callback && callback();
                this.emit("transaction_done");
            }
        });
        if (statusCode.isNotGood()) {
            // the message has not been sent, we need to raise an exception
            return this.send_response(msgType, new services_1.ServiceFault({ responseHeader: { serviceResult: statusCode } }), message, callback);
        }
    }
    getRemoteIPAddress() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")?._socket?.remoteAddress || "";
    }
    getRemotePort() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")?._socket?.remotePort || 0;
    }
    getRemoteFamily() {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")?._socket?.remoteFamily || "";
    }
    /**
     * Abruptly close a Server SecureChannel ,by terminating the underlying transport.
     *
     */
    close(callback) {
        callback = callback || (() => { });
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")) {
            if (typeof callback === "function") {
                callback();
            }
            return;
        }
        debugLog("ServerSecureChannelLayer#close");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closing", "f");
        // close socket
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").disconnect(() => {
            __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closed", "f");
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__abort).call(this);
            if (typeof callback === "function") {
                callback();
            }
        });
    }
    async checkCertificate(certificate) {
        if (!certificate) {
            return node_opcua_status_code_1.StatusCodes.Good;
        }
        // istanbul ignore next
        if (!this.certificateManager) {
            return node_opcua_status_code_1.StatusCodes.BadInternalError;
        }
        const statusCode = await this.certificateManager.checkCertificate(certificate);
        if (statusCode.isGood()) {
            const certInfo = (0, web_1.exploreCertificate)(certificate);
            if (!certInfo.tbsCertificate.extensions?.keyUsage?.dataEncipherment) {
                return node_opcua_status_code_1.StatusCodes.BadCertificateUseNotAllowed;
            }
            if (!certInfo.tbsCertificate.extensions?.keyUsage?.digitalSignature) {
                return node_opcua_status_code_1.StatusCodes.BadCertificateUseNotAllowed;
            }
        }
        return statusCode;
    }
    write(messageChunk) {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").write(messageChunk);
    }
}
exports.ServerSecureChannelLayer = ServerSecureChannelLayer;
_a = ServerSecureChannelLayer, _ServerSecureChannelLayer_counter = new WeakMap(), _ServerSecureChannelLayer_status = new WeakMap(), _ServerSecureChannelLayer_messageBuilder = new WeakMap(), _ServerSecureChannelLayer_parent = new WeakMap(), _ServerSecureChannelLayer_protocolVersion = new WeakMap(), _ServerSecureChannelLayer_lastTokenId = new WeakMap(), _ServerSecureChannelLayer_defaultSecureTokenLifetime = new WeakMap(), _ServerSecureChannelLayer_clientCertificate = new WeakMap(), _ServerSecureChannelLayer_clientPublicKey = new WeakMap(), _ServerSecureChannelLayer_clientPublicKeyLength = new WeakMap(), _ServerSecureChannelLayer_messageChunker = new WeakMap(), _ServerSecureChannelLayer_timeoutId = new WeakMap(), _ServerSecureChannelLayer_open_secure_channel_onceClose = new WeakMap(), _ServerSecureChannelLayer_securityTokenTimeout = new WeakMap(), _ServerSecureChannelLayer_transactionsCount = new WeakMap(), _ServerSecureChannelLayer_transport = new WeakMap(), _ServerSecureChannelLayer_objectFactory = new WeakMap(), _ServerSecureChannelLayer_last_transaction_stats = new WeakMap(), _ServerSecureChannelLayer_startReceiveTick = new WeakMap(), _ServerSecureChannelLayer_endReceiveTick = new WeakMap(), _ServerSecureChannelLayer_startSendResponseTick = new WeakMap(), _ServerSecureChannelLayer_endSendResponseTick = new WeakMap(), _ServerSecureChannelLayer__bytesRead_before = new WeakMap(), _ServerSecureChannelLayer__bytesWritten_before = new WeakMap(), _ServerSecureChannelLayer__remoteAddress = new WeakMap(), _ServerSecureChannelLayer__remotePort = new WeakMap(), _ServerSecureChannelLayer_abort_has_been_called = new WeakMap(), _ServerSecureChannelLayer_idVerification = new WeakMap(), _ServerSecureChannelLayer_transport_socket_close_listener = new WeakMap(), _ServerSecureChannelLayer_tokenStack = new WeakMap(), _ServerSecureChannelLayer_instances = new WeakSet(), _ServerSecureChannelLayer__build_message_builder = function _ServerSecureChannelLayer__build_message_builder() {
    // use to receive client requests
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_messageBuilder, new message_builder_1.MessageBuilder(__classPrivateFieldGet(this, _ServerSecureChannelLayer_tokenStack, "f").clientKeyProvider(), {
        name: "server",
        objectFactory: __classPrivateFieldGet(this, _ServerSecureChannelLayer_objectFactory, "f"),
        privateKey: this.getPrivateKey(),
        maxChunkSize: __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").receiveBufferSize,
        maxChunkCount: __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxChunkCount,
        maxMessageSize: __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxMessageSize
    }), "f");
    debugLog(" this.transport.maxChunkCount", __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxChunkCount);
    debugLog(" this.transport.maxMessageSize", __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxMessageSize);
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").on("error", (err, statusCode) => {
        warningLog("ServerSecureChannel:MessageBuilder: ", err.message, statusCode.toString());
        // istanbul ignore next
        if (doDebug) {
            debugLog(chalk_1.default.red("Error "), err.message, err.stack);
            debugLog(chalk_1.default.red("Server is now closing socket, without further notice"));
        }
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").sendErrorMessage(statusCode, err.message);
        // close socket immediately
        this.close(() => {
            /* */
        });
    });
}, _ServerSecureChannelLayer__sendFatalErrorAndAbort = function _ServerSecureChannelLayer__sendFatalErrorAndAbort(statusCode, description, message, callback) {
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").sendErrorMessage(statusCode, description);
    if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")) {
        return callback(new Error("Transport has been closed"));
    }
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closing", "f");
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").disconnect(() => {
        this.close(() => {
            __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closed", "f");
            callback(new Error(description + " statusCode = " + statusCode.toString()));
        });
    });
}, _ServerSecureChannelLayer__has_endpoint_for_security_mode_and_policy = function _ServerSecureChannelLayer__has_endpoint_for_security_mode_and_policy(securityMode, securityPolicy) {
    if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_parent, "f")) {
        return true;
    }
    const endpoint_desc = this.getEndpointDescription(securityMode, securityPolicy, null);
    return endpoint_desc !== null;
}, _ServerSecureChannelLayer__rememberClientAddressAndPort = function _ServerSecureChannelLayer__rememberClientAddressAndPort() {
    if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f") && __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")._socket) {
        __classPrivateFieldSet(this, _ServerSecureChannelLayer__remoteAddress, __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")._socket.remoteAddress || "", "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer__remotePort, __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f")._socket.remotePort || 0, "f");
    }
}, _ServerSecureChannelLayer__stop_security_token_watch_dog = function _ServerSecureChannelLayer__stop_security_token_watch_dog() {
    if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_securityTokenTimeout, "f")) {
        clearTimeout(__classPrivateFieldGet(this, _ServerSecureChannelLayer_securityTokenTimeout, "f"));
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_securityTokenTimeout, null, "f");
    }
}, _ServerSecureChannelLayer__start_security_token_watch_dog = function _ServerSecureChannelLayer__start_security_token_watch_dog(securityToken) {
    // install securityToken timeout watchdog
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_securityTokenTimeout, setTimeout(() => {
        warningLog(" Security token has really expired and shall be discarded !!!! (lifetime is = ", securityToken.revisedLifetime, ")");
        warningLog(" Server will now refuse message with token ", securityToken.tokenId);
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_securityTokenTimeout, null, "f");
    }, (securityToken.revisedLifetime * 125) / 100), "f");
}, _ServerSecureChannelLayer__prepare_security_token = function _ServerSecureChannelLayer__prepare_security_token(openSecureChannelRequest, derivedKeys) {
    const adjustLifetime = (requestedLifetime) => {
        let revisedLifetime = requestedLifetime;
        if (revisedLifetime === 0) {
            revisedLifetime = __classPrivateFieldGet(this, _ServerSecureChannelLayer_defaultSecureTokenLifetime, "f");
        }
        else {
            revisedLifetime = Math.min(__classPrivateFieldGet(this, _ServerSecureChannelLayer_defaultSecureTokenLifetime, "f"), revisedLifetime);
            revisedLifetime = Math.max(_a.g_MinimumSecureTokenLifetime, revisedLifetime);
        }
        return revisedLifetime;
    };
    if (openSecureChannelRequest.requestType === services_1.SecurityTokenRequestType.Renew) {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_security_token_watch_dog).call(this);
    }
    const requestedLifetime = openSecureChannelRequest.requestedLifetime;
    const revisedLifetime = adjustLifetime(requestedLifetime);
    doDebug && debugLog("revisedLifeTime = ", revisedLifetime, "requestedLifeTime = ", requestedLifetime);
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_lastTokenId, __classPrivateFieldGet(this, _ServerSecureChannelLayer_lastTokenId, "f") + 1, "f");
    const securityToken = new node_opcua_service_secure_channel_1.ChannelSecurityToken({
        channelId: this.channelId,
        createdAt: new Date(), // now
        revisedLifetime,
        tokenId: __classPrivateFieldGet(this, _ServerSecureChannelLayer_lastTokenId, "f") // todo ?
    });
    if ((0, node_opcua_service_secure_channel_1.hasTokenExpired)(securityToken)) {
        warningLog("Token has already expired", securityToken);
    }
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__start_security_token_watch_dog).call(this, securityToken);
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_tokenStack, "f").pushNewToken(securityToken, derivedKeys);
    return securityToken;
}, _ServerSecureChannelLayer__stop_open_channel_watch_dog = function _ServerSecureChannelLayer__stop_open_channel_watch_dog() {
    if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_timeoutId, "f")) {
        clearTimeout(__classPrivateFieldGet(this, _ServerSecureChannelLayer_timeoutId, "f"));
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_timeoutId, null, "f");
    }
    if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_open_secure_channel_onceClose, "f")) {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").removeListener("close", __classPrivateFieldGet(this, _ServerSecureChannelLayer_open_secure_channel_onceClose, "f"));
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_open_secure_channel_onceClose, null, "f");
    }
}, _ServerSecureChannelLayer__cleanup_pending_timers = function _ServerSecureChannelLayer__cleanup_pending_timers() {
    // there is no need for the security token expiration event to trigger anymore
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_security_token_watch_dog).call(this);
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_open_channel_watch_dog).call(this);
}, _ServerSecureChannelLayer__cancel_wait_for_open_secure_channel_request_timeout = function _ServerSecureChannelLayer__cancel_wait_for_open_secure_channel_request_timeout() {
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_open_channel_watch_dog).call(this);
}, _ServerSecureChannelLayer__install_wait_for_open_secure_channel_request_timeout = function _ServerSecureChannelLayer__install_wait_for_open_secure_channel_request_timeout(timeout) {
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_open_secure_channel_onceClose, (err) => {
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_open_secure_channel_onceClose, null, "f");
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_open_channel_watch_dog).call(this);
        this.close(() => {
            const err = new Error("Timeout waiting for OpenChannelRequest (A) (timeout was " + timeout + " ms)");
            this.emit("abort", err);
        });
    }, "f");
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").prependOnceListener("close", __classPrivateFieldGet(this, _ServerSecureChannelLayer_open_secure_channel_onceClose, "f"));
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_timeoutId, setTimeout(() => {
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_timeoutId, null, "f");
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__stop_open_channel_watch_dog).call(this);
        const err = new Error("Timeout waiting for OpenChannelRequest (B) (timeout was " + timeout + " ms)");
        debugLog(err.message);
        this.close(() => {
            // 
        });
    }, timeout), "f");
}, _ServerSecureChannelLayer__on_initial_open_secure_channel_request = function _ServerSecureChannelLayer__on_initial_open_secure_channel_request(request, requestId, channelId) {
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "connecting", "f");
    /* istanbul ignore next */
    if (utils_1.doTraceServerMessage) {
        (0, utils_1.traceRequestMessage)(request, channelId, __classPrivateFieldGet(this, _ServerSecureChannelLayer_counter, "f"));
    }
    /* istanbul ignore next */
    if (!(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f") && __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").sequenceHeader && __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityHeader)) {
        const securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({ securityPolicyUri: security_policy_1.SecurityPolicy.None });
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, node_opcua_status_code_1.StatusCodes.BadCommunicationError, "internal error", { request, requestId, securityHeader });
    }
    const message = {
        request,
        requestId,
        securityHeader: __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityHeader
    };
    //xx  requestId = this.messageBuilder.sequenceHeader.requestId;
    /* istanbul ignore next */
    if (requestId < 0) {
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, node_opcua_status_code_1.StatusCodes.BadCommunicationError, "Invalid requestId", message);
    }
    let description = "";
    // expecting a OpenChannelRequest as first communication message
    /* istanbul ignore next */
    if (!(request instanceof services_1.OpenSecureChannelRequest)) {
        description = "Expecting OpenSecureChannelRequest";
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, node_opcua_status_code_1.StatusCodes.BadCommunicationError, description, message);
    }
    // check that the request is a OpenSecureChannelRequest
    /* istanbul ignore next */
    if (doDebug) {
        debugLog(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").sequenceHeader.toString());
        debugLog(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityHeader.toString());
        debugLog(request.toString());
    }
    const asymmetricSecurityHeader = __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityHeader;
    const securityMode = request.securityMode;
    this.securityMode = securityMode;
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityMode = securityMode;
    const securityPolicy = message.securityHeader
        ? (0, security_policy_1.fromURI)(asymmetricSecurityHeader.securityPolicyUri)
        : security_policy_1.SecurityPolicy.Invalid;
    // check security header
    const securityPolicyStatus = isValidSecurityPolicy(securityPolicy);
    if (securityPolicyStatus !== node_opcua_status_code_1.StatusCodes.Good) {
        description = " Unsupported securityPolicyUri " + asymmetricSecurityHeader.securityPolicyUri;
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, securityPolicyStatus, description, message);
    }
    const hasEndpoint = __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__has_endpoint_for_security_mode_and_policy).call(this, securityMode, securityPolicy);
    if (!hasEndpoint) {
        // there is no
        description = " This server doesn't not support  " + securityPolicy.toString() + " " + securityMode.toString();
        return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, node_opcua_status_code_1.StatusCodes.BadSecurityPolicyRejected, description, message);
    }
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f")
        .on("message", (request, msgType, securityHeader, requestId, channelId) => {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_common_message).call(this, request, msgType, securityHeader, requestId, channelId);
    })
        .on("error", (err, statusCode, requestId) => {
        /** */
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").sendErrorMessage(statusCode, err.message);
        this.close(() => {
            /** */
        });
    })
        .on("startChunk", () => {
        /* istanbul ignore next */
        if (utils_1.doPerfMonitoring) {
            // record tick 0: when the first chunk is received
            __classPrivateFieldSet(this, _ServerSecureChannelLayer_startReceiveTick, (0, node_opcua_utils_1.get_clock_tick)(), "f");
        }
    });
    // handle initial OpenSecureChannelRequest
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__process_certificates).call(this, message, (err, statusCode) => {
        // istanbul ignore next
        if (err || !statusCode) {
            description = "Internal Error " + err?.message;
            return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, statusCode || node_opcua_status_code_1.StatusCodes.BadInternalError, description, message);
        }
        if (statusCode.isNotGood()) {
            warningLog("Sender Certificate thumbprint ", (0, common_1.getThumbprint)(asymmetricSecurityHeader.senderCertificate));
            // OPCUA specification v1.02 part 6 page 42 $6.7.4
            // If an error occurs after the  Server  has verified  Message  security  it  shall  return a  ServiceFault  instead
            // of a OpenSecureChannel  response. The  ServiceFault  Message  is described in  Part  4,   7.28.
            if (statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateIssuerRevocationUnknown) &&
                statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateRevocationUnknown) &&
                statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateTimeInvalid) &&
                statusCode.isNot(node_opcua_status_code_1.StatusCodes.BadCertificateUseNotAllowed)) {
                statusCode = node_opcua_status_code_1.StatusCodes.BadSecurityChecksFailed;
            }
            // Those are not considered as error but as a warning
            //    BadCertificateIssuerRevocationUnknown,
            //    BadCertificateRevocationUnknown,
            //    BadCertificateTimeInvalid,
            //    BadCertificateUseNotAllowed
            //
            // the client will decided what to do next
            return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, statusCode, "certificate invalid", message);
        }
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__handle_OpenSecureChannelRequest).call(this, message);
    });
}, _ServerSecureChannelLayer__wait_for_open_secure_channel_request = function _ServerSecureChannelLayer__wait_for_open_secure_channel_request(timeout) {
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__install_wait_for_open_secure_channel_request_timeout).call(this, timeout);
    const errorHandler = (err) => {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__cancel_wait_for_open_secure_channel_request_timeout).call(this);
        if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f")) {
            __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").removeListener("message", messageHandler);
            const err = new Error("/Expecting OpenSecureChannelRequest to be valid ");
            this.emit("abort", err);
        }
    };
    const messageHandler = (request, msgType, securityHeader, requestId, channelId) => {
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__cancel_wait_for_open_secure_channel_request_timeout).call(this);
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").removeListener("error", errorHandler);
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_initial_open_secure_channel_request).call(this, request, requestId, channelId);
    };
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").prependOnceListener("error", errorHandler);
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").once("message", messageHandler);
}, _ServerSecureChannelLayer__send_chunk = function _ServerSecureChannelLayer__send_chunk(messageChunk) {
    this.write(messageChunk);
}, _ServerSecureChannelLayer__get_security_options_for_OPN = function _ServerSecureChannelLayer__get_security_options_for_OPN() {
    // The OpenSecureChannel Messages are signed and encrypted if the SecurityMode is
    // not None(even  if the SecurityMode is Sign).
    if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
        return null;
    }
    const senderPrivateKey = this.getPrivateKey();
    /* istanbul ignore next */
    if (!senderPrivateKey) {
        throw new Error("invalid or missing senderPrivateKey : necessary to sign");
    }
    const cryptoFactory = (0, security_policy_1.getCryptoFactory)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityPolicy);
    /* istanbul ignore next */
    if (!cryptoFactory) {
        throw new Error("Internal Error: ServerSecureChannelLayer must have a crypto strategy");
    }
    (0, node_opcua_assert_1.assert)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_clientPublicKeyLength, "f") >= 0);
    const receiverPublicKey = __classPrivateFieldGet(this, _ServerSecureChannelLayer_clientPublicKey, "f");
    if (!receiverPublicKey) {
        // this could happen if certificate was wrong
        // throw new Error("Invalid receiverPublicKey");
        return null;
    }
    const keyLength = (0, web_1.rsaLengthPublicKey)(receiverPublicKey);
    const signatureLength = (0, web_1.rsaLengthPrivateKey)(senderPrivateKey);
    const options = {
        // for signing
        signatureLength,
        signBufferFunc: (chunk) => cryptoFactory.asymmetricSign(chunk, senderPrivateKey),
        // for encrypting
        cipherBlockSize: keyLength,
        plainBlockSize: keyLength - cryptoFactory.blockPaddingSize,
        encryptBufferFunc: (chunk) => cryptoFactory.asymmetricEncrypt(chunk, receiverPublicKey)
    };
    return options;
}, _ServerSecureChannelLayer__get_security_options_for_MSG = function _ServerSecureChannelLayer__get_security_options_for_MSG(tokenId) {
    if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
        return null;
    }
    const derivedKeys = __classPrivateFieldGet(this, _ServerSecureChannelLayer_tokenStack, "f").getTokenDerivedKeys(tokenId);
    // istanbul ignore next
    if (!derivedKeys || !derivedKeys.derivedServerKeys) {
        errorLog("derivedKeys not set but security mode = ", node_opcua_service_secure_channel_1.MessageSecurityMode[this.securityMode]);
        return null;
    }
    const options = (0, security_policy_1.getOptionsForSymmetricSignAndEncrypt)(this.securityMode, derivedKeys.derivedServerKeys);
    return options;
}, _ServerSecureChannelLayer__process_certificates = function _ServerSecureChannelLayer__process_certificates(message, callback) {
    const asymmSecurityHeader = message.securityHeader;
    // verify certificate
    let clientCertificate = asymmSecurityHeader ? asymmSecurityHeader.senderCertificate : null;
    this.checkCertificate(clientCertificate)
        .then((statusCode) => {
        if (statusCode.isNotGood()) {
            const description = "Sender Certificate Error " + statusCode.toString();
            warningLog(chalk_1.default.cyan(description), chalk_1.default.bgCyan.yellow(statusCode.toString()));
            const chain = (0, web_1.split_der)(clientCertificate);
            warningLog("Sender Certificate = ", chain.map((c) => (0, common_1.getThumbprint)(clientCertificate)?.toString("hex")).join("\n"));
        }
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientCertificate, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKey, null, "f");
        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKeyLength, 0, "f");
        // ignore receiverCertificate that have a zero length
        /* istanbul ignore next */
        if (clientCertificate && clientCertificate.length === 0) {
            clientCertificate = null;
        }
        if (clientCertificate) {
            // extract public key
            (0, web_1.extractPublicKeyFromCertificate)(clientCertificate, (err, keyPem) => {
                if (!err) {
                    if (keyPem) {
                        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientCertificate, clientCertificate, "f");
                        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKey, (0, crypto_1.createPublicKey)(keyPem), "f");
                        __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKeyLength, (0, web_1.rsaLengthPublicKey)(keyPem), "f");
                    }
                    callback(null, statusCode);
                }
                else {
                    callback(err);
                }
            });
        }
        else {
            __classPrivateFieldSet(this, _ServerSecureChannelLayer_clientPublicKey, null, "f");
            callback(null, statusCode);
        }
    }).catch((err) => callback(err));
}, _ServerSecureChannelLayer__prepare_response_security_header = function _ServerSecureChannelLayer__prepare_response_security_header(request, message) {
    let securityHeader;
    // senderCertificate:
    //    The X509v3 certificate assigned to the sending application instance.
    //    This is a DER encoded blob.
    //    This indicates what private key was used to sign the MessageChunk.
    //    This field shall be null if the message is not signed.
    // receiverCertificateThumbprint:
    //    The thumbprint of the X509v3 certificate assigned to the receiving application
    //    The thumbprint is the SHA1 digest of the DER encoded form of the certificate.
    //    This indicates what public key was used to encrypt the MessageChunk
    //   This field shall be null if the message is not encrypted.
    const evaluateReceiverThumbprint = () => {
        if (this.securityMode === node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
            return null;
        }
        const part1 = (0, web_1.split_der)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_clientCertificate, "f"))[0];
        const receiverCertificateThumbprint = (0, common_1.getThumbprint)(part1);
        return receiverCertificateThumbprint;
    };
    switch (request.securityMode) {
        case node_opcua_service_secure_channel_1.MessageSecurityMode.None:
            this.securityPolicy = security_policy_1.SecurityPolicy.None;
            securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
                receiverCertificateThumbprint: null, // message not encrypted
                securityPolicyUri: security_policy_1.SecurityPolicy.None,
                senderCertificate: null // message not signed
            });
            break;
        case node_opcua_service_secure_channel_1.MessageSecurityMode.Sign:
        case node_opcua_service_secure_channel_1.MessageSecurityMode.SignAndEncrypt:
        default: {
            const receiverCertificateThumbprint = evaluateReceiverThumbprint();
            const asymmClientSecurityHeader = message.securityHeader;
            this.securityPolicy = (0, security_policy_1.coerceSecurityPolicy)(asymmClientSecurityHeader.securityPolicyUri || security_policy_1.SecurityPolicy.Invalid);
            const maxSenderCertificateSize = undefined;
            const partialCertificateChain = (0, node_opcua_common_1.getPartialCertificateChain)(this.getCertificateChain(), maxSenderCertificateSize);
            if (this.securityPolicy === security_policy_1.SecurityPolicy.Invalid) {
                warningLog("Invalid Security Policy", this.securityPolicy);
            }
            // istanbul ignore next
            securityHeader = new services_1.AsymmetricAlgorithmSecurityHeader({
                securityPolicyUri: asymmClientSecurityHeader.securityPolicyUri,
                /**
                 * The thumbprint of the X.509 v3 Certificate assigned to the receiving application Instance.
                 * The thumbprint is the CertificateDigest of the DER encoded form of the Certificate.
                 * This indicates what public key was used to encrypt the MessageChunk.
                 * This field shall be null if the Message is not encrypted.
                 */
                receiverCertificateThumbprint,
                /**
                 * The X.509 v3 Certificate assigned to the sending application Instance.
                 *  This is a DER encoded blob.
                 * The structure of an X.509 v3 Certificate is defined in X.509 v3.
                 * The DER format for a Certificate is defined in X690
                 * This indicates what Private Key was used to sign the MessageChunk.
                 * The Stack shall close the channel and report an error to the application
                 * if the SenderCertificate is too large for the buffer size supported by the transport layer.
                 * This field shall be null if the Message is not signed.
                 * If the Certificate is signed by a CA, the DER encoded CA Certificate may be
                 * appended after the Certificate in the byte array. If the CA Certificate is also
                 * signed by another CA this process is repeated until the entire Certificate chain
                 * is in the buffer or if MaxSenderCertificateSize limit is reached (the process
                 * stops after the last whole Certificate that can be added without exceeding
                 * the MaxSenderCertificateSize limit).
                 * Receivers can extract the Certificates from the byte array by using the Certificate
                 * size contained in DER header (see X.509 v3).
                 */
                senderCertificate: partialCertificateChain // certificate of the private key used to sign the message
            });
        }
    }
    return securityHeader;
}, _ServerSecureChannelLayer__check_client_nonce = function _ServerSecureChannelLayer__check_client_nonce(clientNonce) {
    if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
        const cryptoFactory = (0, security_policy_1.getCryptoFactory)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityPolicy);
        if (!cryptoFactory) {
            return node_opcua_status_code_1.StatusCodes.BadSecurityModeRejected;
        }
        if (clientNonce.length !== cryptoFactory.symmetricKeyLength) {
            warningLog(chalk_1.default.red("warning client Nonce length doesn't match server nonce length"), clientNonce.length, " !== ", cryptoFactory.symmetricKeyLength);
            // what can we do
            // - just ignore it ?
            // - or adapt serverNonce length to clientNonce Length ?
            // xx self.serverNonce = crypto.randomBytes(self.clientNonce.length);
            // - or adapt clientNonce length to serverNonce Length ?
            // xx self.clientNonce = self.clientNonce.subarray(0,self.serverNonce.length);
            //
            // - or abort connection ? << LET BE SAFE AND CHOOSE THIS ONE !
            return node_opcua_status_code_1.StatusCodes.BadSecurityModeRejected; // ToDo check code
        }
        /* istanbul ignore next */
        if (nonceAlreadyBeenUsed(clientNonce)) {
            warningLog(chalk_1.default.red("OPCUAServer with secure connection: this client nonce has already been used"), clientNonce.toString("hex"));
            return node_opcua_status_code_1.StatusCodes.BadNonceInvalid;
        }
    }
    return node_opcua_status_code_1.StatusCodes.Good;
}, _ServerSecureChannelLayer__make_serverNonce = function _ServerSecureChannelLayer__make_serverNonce() {
    if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
        const cryptoFactory = (0, security_policy_1.getCryptoFactory)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityPolicy);
        // serverNonce: A random number that shall not be used in any other request. A new
        //    serverNonce shall be generated for each time a SecureChannel is renewed.
        //    This parameter shall have a length equal to key size used for the symmetric
        //    encryption algorithm that is identified by the securityPolicyUri.
        return (0, crypto_1.randomBytes)(cryptoFactory.symmetricKeyLength);
    }
    return null;
}, _ServerSecureChannelLayer__make_derivedKeys = function _ServerSecureChannelLayer__make_derivedKeys(serverNonce, clientNonce) {
    if (this.securityMode !== node_opcua_service_secure_channel_1.MessageSecurityMode.None) {
        if (!serverNonce || !clientNonce) {
            throw new Error("Internal Error");
        }
        const cryptoFactory = (0, security_policy_1.getCryptoFactory)(__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").securityPolicy);
        return (0, security_policy_1.computeDerivedKeys)(cryptoFactory, serverNonce, clientNonce);
    }
    return null;
}, _ServerSecureChannelLayer__handle_OpenSecureChannelRequest = function _ServerSecureChannelLayer__handle_OpenSecureChannelRequest(messageRequest) {
    this.beforeHandleOpenSecureChannelRequest().then(() => {
        let description;
        // If the SecurityMode is not None then the Server shall verify that a SenderCertificate and a
        // ReceiverCertificateThumbprint were specified in the SecurityHeader.
        /* istanbul ignore next */
        if (!messageRequest.securityHeader) {
            throw new Error("Internal Error");
        }
        const request = messageRequest.request;
        const requestId = messageRequest.requestId;
        // let prepare self.securityHeader;
        const securityHeader = __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__prepare_response_security_header).call(this, request, messageRequest);
        /* istanbul ignore next */
        if (!(requestId !== 0 && requestId > 0)) {
            warningLog("OpenSecureChannelRequest: requestId");
            return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, node_opcua_transport_1.StatusCodes2.BadTcpInternalError, "invalid request", messageRequest);
        }
        const statusCodeClientNonce = __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__check_client_nonce).call(this, request.clientNonce);
        if (statusCodeClientNonce.isNotGood()) {
            return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, statusCodeClientNonce, "invalid nonce", messageRequest);
        }
        if (!__classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__check_receiverCertificateThumbprint).call(this, messageRequest.securityHeader)) {
            description =
                "Server#OpenSecureChannelRequest : Invalid receiver certificate thumbprint : the thumbprint doesn't match server certificate !";
            return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__on_OpenSecureChannelRequestError).call(this, node_opcua_status_code_1.StatusCodes.BadCertificateInvalid, description, messageRequest);
        }
        const serverNonce = __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__make_serverNonce).call(this);
        const derivedKeys = __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__make_derivedKeys).call(this, serverNonce, request.clientNonce);
        const securityToken = __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__prepare_security_token).call(this, request, derivedKeys);
        const response = new services_1.OpenSecureChannelResponse({
            responseHeader: { serviceResult: node_opcua_status_code_1.StatusCodes.Good },
            securityToken: securityToken,
            serverNonce: serverNonce || undefined,
            serverProtocolVersion: __classPrivateFieldGet(this, _ServerSecureChannelLayer_protocolVersion, "f")
        });
        /* istanbul ignore next */
        if (utils_1.doTraceServerMessage) {
            console.log("Transport maxMessageSize = ", __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxMessageSize);
            console.log("Transport maxChunkCount  = ", __classPrivateFieldGet(this, _ServerSecureChannelLayer_transport, "f").maxChunkCount);
        }
        const messageResponse = {
            ...messageRequest,
            securityHeader: securityHeader
        };
        this.send_response("OPN", response, messageResponse, (err) => {
            const responseHeader = response.responseHeader;
            if (responseHeader.serviceResult !== node_opcua_status_code_1.StatusCodes.Good) {
                warningLog("OpenSecureChannelRequest Closing communication ", responseHeader.serviceResult.toString());
                __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closing", "f");
                this.close();
            }
            else {
                __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "open", "f");
            }
        });
    });
}, _ServerSecureChannelLayer__abort = function _ServerSecureChannelLayer__abort() {
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closed", "f");
    debugLog("ServerSecureChannelLayer#_abort");
    if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_abort_has_been_called, "f")) {
        debugLog("Warning => ServerSecureChannelLayer#_abort has already been called");
        return;
    }
    _a.registry.unregister(this);
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_abort_has_been_called, true, "f");
    __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__cleanup_pending_timers).call(this);
    /**
     * notify the observers that the SecureChannel has aborted.
     * the reason could be :
     *   - a CloseSecureChannelRequest has been received.
     *   - a invalid message has been received
     * the event is sent after the underlying transport layer has been closed.
     *
     * @event abort
     */
    this.emit("abort");
    debugLog("ServerSecureChannelLayer emitted abort event");
}, _ServerSecureChannelLayer__record_transaction_statistics = function _ServerSecureChannelLayer__record_transaction_statistics() {
    __classPrivateFieldSet(this, _ServerSecureChannelLayer__bytesRead_before, __classPrivateFieldGet(this, _ServerSecureChannelLayer__bytesRead_before, "f") || 0, "f");
    __classPrivateFieldSet(this, _ServerSecureChannelLayer__bytesWritten_before, __classPrivateFieldGet(this, _ServerSecureChannelLayer__bytesWritten_before, "f") || 0, "f");
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_last_transaction_stats, {
        bytesRead: this.bytesRead - __classPrivateFieldGet(this, _ServerSecureChannelLayer__bytesRead_before, "f"),
        bytesWritten: this.bytesWritten - __classPrivateFieldGet(this, _ServerSecureChannelLayer__bytesWritten_before, "f"),
        lap_reception: __classPrivateFieldGet(this, _ServerSecureChannelLayer_endReceiveTick, "f") - __classPrivateFieldGet(this, _ServerSecureChannelLayer_startReceiveTick, "f"),
        lap_processing: __classPrivateFieldGet(this, _ServerSecureChannelLayer_startSendResponseTick, "f") - __classPrivateFieldGet(this, _ServerSecureChannelLayer_endReceiveTick, "f"),
        lap_emission: __classPrivateFieldGet(this, _ServerSecureChannelLayer_endSendResponseTick, "f") - __classPrivateFieldGet(this, _ServerSecureChannelLayer_startSendResponseTick, "f")
    }, "f");
    // final operation in statistics
    __classPrivateFieldSet(this, _ServerSecureChannelLayer__bytesRead_before, this.bytesRead, "f");
    __classPrivateFieldSet(this, _ServerSecureChannelLayer__bytesWritten_before, this.bytesWritten, "f");
}, _ServerSecureChannelLayer__on_common_message = function _ServerSecureChannelLayer__on_common_message(request, msgType, securityHeader, requestId, channelId) {
    /* istanbul ignore next */
    if (utils_1.doTraceServerMessage) {
        (0, utils_1.traceRequestMessage)(request, channelId, __classPrivateFieldGet(this, _ServerSecureChannelLayer_counter, "f"));
    }
    /* istanbul ignore next */
    if (__classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").sequenceHeader === null) {
        throw new Error("Internal Error");
    }
    requestId = __classPrivateFieldGet(this, _ServerSecureChannelLayer_messageBuilder, "f").sequenceHeader.requestId;
    const message = {
        channel: this,
        request,
        securityHeader,
        requestId
    };
    if (msgType === "CLO" /* && request.schema.name === "CloseSecureChannelRequest" */) {
        this.close();
    }
    else if (msgType === "OPN" && request.schema.name === "OpenSecureChannelRequest") {
        // intercept client request to renew security Token
        __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__handle_OpenSecureChannelRequest).call(this, message);
    }
    else {
        if (request.schema.name === "CloseSecureChannelRequest") {
            warningLog("WARNING : RECEIVED a CloseSecureChannelRequest with msgType=", msgType);
            this.close();
        }
        else {
            /* istanbul ignore next */
            if (utils_1.doPerfMonitoring) {
                // record tick 1 : after message has been received, before message processing
                __classPrivateFieldSet(this, _ServerSecureChannelLayer_endReceiveTick, (0, node_opcua_utils_1.get_clock_tick)(), "f");
            }
            const getTokenId = (securityHeader) => {
                if (securityHeader instanceof node_opcua_service_secure_channel_1.SymmetricAlgorithmSecurityHeader) {
                    return securityHeader.tokenId;
                }
                return 0;
            };
            const tokenId = getTokenId(securityHeader);
            const securityToken = __classPrivateFieldGet(this, _ServerSecureChannelLayer_tokenStack, "f").getToken(tokenId);
            if (!securityToken) {
                const _tokenStack = __classPrivateFieldGet(this, _ServerSecureChannelLayer_tokenStack, "f");
                const description = `cannot find security token ${tokenId}  ${msgType}`;
                return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__sendFatalErrorAndAbort).call(this, node_opcua_status_code_1.StatusCodes.BadCommunicationError, description, message, () => { });
            }
            if (securityToken && channelId !== securityToken.channelId) {
                // response = new ServiceFault({responseHeader: {serviceResult: certificate_status}});
                const description = `Invalid channelId specified = ${channelId}  <> ${securityToken.channelId}`;
                return __classPrivateFieldGet(this, _ServerSecureChannelLayer_instances, "m", _ServerSecureChannelLayer__sendFatalErrorAndAbort).call(this, node_opcua_status_code_1.StatusCodes.BadCommunicationError, description, message, () => {
                    /** */
                });
            }
            /**
             * notify the observer that a OPCUA message has been received.
             * It is up to one observer to call send_response or _send_ServiceFault_and_abort to complete
             * the transaction.
             */
            this.emit("message", message);
        }
    }
}, _ServerSecureChannelLayer__check_receiverCertificateThumbprint = function _ServerSecureChannelLayer__check_receiverCertificateThumbprint(clientSecurityHeader) {
    if (clientSecurityHeader instanceof node_opcua_service_secure_channel_1.SymmetricAlgorithmSecurityHeader) {
        return true; // nothing we can do here
    }
    if (clientSecurityHeader.receiverCertificateThumbprint) {
        // check if the receiverCertificateThumbprint is my certificate thumbprint
        const serverCertificate = this.getCertificate();
        const myCertificateThumbPrint = (0, web_1.makeSHA1Thumbprint)(serverCertificate);
        const myCertificateThumbPrintHex = myCertificateThumbPrint.toString("hex");
        const receiverCertificateThumbprintHex = clientSecurityHeader.receiverCertificateThumbprint.toString("hex");
        const thisIsMyCertificate = myCertificateThumbPrintHex === receiverCertificateThumbprintHex;
        if (doDebug && !thisIsMyCertificate) {
            debugLog("receiverCertificateThumbprint do not match server certificate", receiverCertificateThumbprintHex + " <> " + myCertificateThumbPrintHex);
        }
        return thisIsMyCertificate;
    }
    return true;
}, _ServerSecureChannelLayer__on_OpenSecureChannelRequestError = function _ServerSecureChannelLayer__on_OpenSecureChannelRequestError(serviceResult, description, message) {
    warningLog("ServerSecureChannel sendError: ", serviceResult.toString(), { description }, message.request.constructor.name);
    this.securityMode = node_opcua_service_secure_channel_1.MessageSecurityMode.None;
    __classPrivateFieldSet(this, _ServerSecureChannelLayer_status, "closing", "f");
    setTimeout(() => {
        this.send_response("ERR", new services_1.ServiceFault({
            responseHeader: {
                serviceResult,
                timestamp: new Date(),
                stringTable: [description, serviceResult.toString()]
            }
        }), message, () => {
            setTimeout(() => {
                this.close();
            }, 1000);
        });
    }, _a.throttleTime); // Throttling keep connection on hold for a while.
};
ServerSecureChannelLayer.throttleTime = 100;
ServerSecureChannelLayer.g_MinimumSecureTokenLifetime = 2500;
ServerSecureChannelLayer.g_counter = 0;
ServerSecureChannelLayer.registry = new node_opcua_object_registry_1.ObjectRegistry();
//# sourceMappingURL=server_secure_channel_layer.js.map